<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>PITCHME.html</title>

</head>

<body>

<hr />

<h1>Perf (mostly SQL)</h1>

<h3>Lunch &amp; Learn Apr 20, 2017</h3>

<h5>Venky Iyer</h5>

<hr />

<h2>Overview</h2>

<p>+++</p>

<ul>
<li>Identifying perf problems</li>
<li>Montage: SQL operations/internals</li>
<li>What affects SQL query performance</li>
<li>EXPLAIN output</li>
<li>Redshift SQL &amp; Hive SQL</li>
</ul>

<!-- Caveats about I am not an expert -->

<hr />

<h2>Where in the stack is the perf bottleneck?</h2>

<p>+++</p>

<p><img src="diagrams/perf-stack.png" alt="perf-stack" title="" /></p>

<hr />

<h2>The optimization loop</h2>

<p>+++</p>

<p><img src="diagrams/opt-loop.png" alt="opt-loop" title="" /></p>

<hr />

<h2>Profilers</h2>

<p>+++</p>

<p><img src="diagrams/profilers.png" alt="profilers" title="" /></p>

<hr />

<h2>NewRelic</h2>

<p>+++</p>

<h3>Apdex = % satisfactory response times</h3>

<ul>
<li>satisfying &lt; tolerable (T) &lt; frustrating (4T)</li>
<li>Global setting of T = 300ms</li>
<li>Response time setting to record "traces" >= 4T</li>
<li>Can be changed on per-transaction level (for key transactions)</li>
</ul>

<p>+++</p>

<h3>Custom instrumentation</h3>

<p>Set or modify transaction names:</p>

<p><code>ruby
  def contacts_results(search_term, tags, page_number: 0, paginate: true)
    transaction_name = NewRelic::Agent.get_transaction_name
    if search_term.blank?
      NewRelic::Agent.set_transaction_name("#{transaction_name} - empty")
    elsif UserConfig.value_for_user_id_and_key(@user.id, 'experimental-search').to_b
      NewRelic::Agent.set_transaction_name("#{transaction_name} - experimental")
    elsif search_term.split(/\s+/).length &gt; 3
      NewRelic::Agent.set_transaction_name("#{transaction_name} - long")
    end
</code>
+++</p>

<p>Measure a block:</p>

<p>```ruby
   include ::NewRelic::Agent::MethodTracer</p>

<p>self.trace<em>execution</em>scoped(['MessageThreadTagsController/log<em>work</em>action']) do
     log<em>work</em>action(:message<em>thread</em>tagged, message<em>thread</em>tag, client<em>created</em>at: nil, thread<em>id: params[:message</em>thread<em>id].to</em>i)
   end
```</p>

<p>+++</p>

<p>Split out a method:</p>

<p><code>ruby
add_method_tracer :contacts_results, 'ClientSearch/contacts_results'
</code></p>

<p>+++</p>

<p>[notes]</p>

<ul>
<li>transactions</li>
<li>traces</li>
<li>database</li>
<li>dashboards</li>
<li>throughput v. slow queries</li>
<li>percentiles</li>
</ul>

<hr />

<h2>Profiling Ruby</h2>

<p>+++</p>

<p><code>!debug</code></p>

<ul>
<li>Turn log level to DEBUG (shows Elasticsearch queries)</li>
<li>Pipe the ActiveRecord query logs to STDOUT</li>
<li>shows backtraces etc</li>
</ul>

<p>[demo]</p>

<hr />

<p><a href="https://github.com/finventures/fin-core-beta/blob/master/.pryrc"><code>.pryrc</code></a></p>

<p>Custom commands:</p>

<ul>
<li>debugger</li>
<li><code>dp</code> | <code>ep</code></li>
<li>backtrace</li>
<li>autocompleter</li>
<li>prompt</li>
</ul>

<hr />

<p><code>Benchmark</code></p>

<p>```ruby</p>

<p>rails> Benchmark.bm do |x|
*   x.report { User.find(2) }
* end
  user     system      total        real
  0.020000   0.010000   0.030000 (  0.031872)</p>

<p>rails> Benchmark.realtime { User.find 2 }
=> 0.004197215981548652</p>

<p>```</p>

<p>+++</p>

<p><code>RubyProf</code></p>

<p>```ruby</p>

<blockquote>
  <p>result = RubyProf.profile { AgentState.event_loop }
printer = RubyProf::CallStackPrinter.new(result)
printer.print(open("./profile2.html", "w"))</p>
</blockquote>

<p>$> open profile2.html</p>

<p>```</p>

<hr />

</body>
</html>
